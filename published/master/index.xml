<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>A Tour of Dgraph</title>
    <link>https://dgraph.io/tour/master/</link>
    <description>Recent content on A Tour of Dgraph</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 15 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://dgraph.io/tour/master/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Indexes</title>
      <link>https://dgraph.io/tour/master/graphqlsearch/1/</link>
      <pubDate>Mon, 15 May 2017 15:31:59 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlsearch/1/</guid>
      <description>When Dgraph searches for strings, dates, or other values based on a filter, it needs an index to make the search efficient. We&amp;rsquo;ve already seen examples of how to specify the indexes in a schema update.
Int, Float, and DateTime have default indexes, but String has a few options for which search index types to use. You can build multiple indexes for the same String-valued predicate.
For String, the following indexes are available:</description>
    </item>
    
    <item>
      <title>Indexes</title>
      <link>https://dgraph.io/tour/master/search/1/</link>
      <pubDate>Mon, 15 May 2017 15:31:59 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/search/1/</guid>
      <description>When Dgraph is searching for strings, dates, or other values based on a filter, it needs an index to make the search efficient. We&amp;rsquo;ve already seen examples of how to specify the indexes in a schema mutation.
int, float, geo and date have default indexes, but string has options of what index types to choose. Multiple indexes can be built for the same string valued predicate.
For string the following indexes are available</description>
    </item>
    
    <item>
      <title>Multiple Named Query Blocks</title>
      <link>https://dgraph.io/tour/master/blocksvars/1/</link>
      <pubDate>Mon, 01 May 2017 13:45:26 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/1/</guid>
      <description>Note From now on, to run the queries, you&amp;rsquo;ll need to have loaded the million triple movie dataset.
 Queries can be issued as multiples.
For queries labeled q1, ..., qn issued as a multiple query block, the JSON result will contain labeled answer blocks q1, ..., qn for each query.
If a block is labeled with var, no results are returned for that query.
Queries issued in this way are independent.</description>
    </item>
    
    <item>
      <title>A Bigger Dataset</title>
      <link>https://dgraph.io/tour/master/graphqlmoredata/1/</link>
      <pubDate>Thu, 27 Apr 2017 15:42:54 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlmoredata/1/</guid>
      <description>OK, we are off to a good start with Dgraph and GraphQL. Now let&amp;rsquo;s see what you can do with Dgraph&amp;rsquo;s advanced capabilities; like query aggregation, geo-queries, and string querying. To do all of this we need to move from the small datasets that we started with and try out something bigger; much bigger.
In the Dgraph GitHub repository, you&amp;rsquo;ll find a dataset about movies, directors and actors. There&amp;rsquo;s around one million triples in the dataset.</description>
    </item>
    
    <item>
      <title>A bigger dataset</title>
      <link>https://dgraph.io/tour/master/moredata/1/</link>
      <pubDate>Thu, 27 Apr 2017 15:42:54 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/moredata/1/</guid>
      <description>Ok, we are off to a start with Dgraph and DQL. Let’s move it up a few notches.
Dgraph can also do query aggregation, geo-queries, string querying and more. But for all that let&amp;rsquo;s move from the small datasets we started with and try out something bigger, much bigger.
In our github repository you&amp;rsquo;ll find a dataset about movies, directors and actors.
Download it from that link and save into the ~/dgraph directory or by running the following in a terminal</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://dgraph.io/tour/master/basic/1/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:18 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/1/</guid>
      <description>Note For the following queries to run, you should have loaded data in the introduction.
 Let’s have a look at a hello world query in DQL.
Every query has a name, and the result is labeled with the same name.
The search criteria func: ... matches nodes. Function eq does what you&amp;rsquo;d expect, matching nodes with a name equalling &amp;ldquo;Michael&amp;rdquo;. The result is the matched nodes and listed outgoing edges from those nodes.</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/1/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:18 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/1/</guid>
      <description>Note For the following queries to run, you should have completed the introduction to setup your backend, define your schema, and insert the sample data. To learn more, see the GraphQL tour introduction.
 Let’s have a look at a &amp;ldquo;hello world&amp;rdquo; query in GraphQL.
Each query has at least one named root function, and query results are labeled accordingly.
Dgraph generates these functions based on a schema that you provide.</description>
    </item>
    
    <item>
      <title>Adding schema - mutating schema</title>
      <link>https://dgraph.io/tour/master/graphqlschema/1/</link>
      <pubDate>Wed, 26 Apr 2017 21:53:48 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlschema/1/</guid>
      <description>As you saw in an earlier lesson, Dgraph accepts a GraphQL schema comprised of types to generate the GraphQL API.
The GraphQL API is a strictly-typed API. You can only add and query data that matches a predefined schema. However, do not let this limitation restrict you from iterating on the schema as needed.
Normally, in GraphQL implementations you would have to define inputs, queries, and mutations in the GraphQL schema being deployed.</description>
    </item>
    
    <item>
      <title>Adding schema - mutating schema</title>
      <link>https://dgraph.io/tour/master/schema/1/</link>
      <pubDate>Wed, 26 Apr 2017 21:53:48 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/schema/1/</guid>
      <description>As we saw in an earlier lesson, Dgraph stores a schema describing the types of predicates.
When we want to add new data to an existing schema, we can just add it. But if we want to add new data in a new schema we have two choices
 Add the data and let Dgraph work out the schema, or Specify a schema and then add the data  Dgraph can work out the schema just fine.</description>
    </item>
    
    <item>
      <title>Welcome</title>
      <link>https://dgraph.io/tour/master/graphqlintro/1/</link>
      <pubDate>Wed, 26 Apr 2017 21:52:39 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlintro/1/</guid>
      <description>Welcome to GraphQL powered by Dgraph database.
This interactive tutorial will get you up and running writing queries in GraphQL using Dgraph Cloud, a Dgraph database backend that we offer as a managed service.
Note To take a tour of Dgraph using Dgraph Query Language (DQL, formerly known as GraphQL+-), please see the DQL-focused portion of this tour. The first five sections of this tour focus exclusively on using Dgraph Cloud with GraphQL.</description>
    </item>
    
    <item>
      <title>Welcome</title>
      <link>https://dgraph.io/tour/master/intro/1/</link>
      <pubDate>Wed, 26 Apr 2017 21:52:39 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/intro/1/</guid>
      <description>Hi,
Welcome to Dgraph.
This interactive tutorial will get you up and running with Dgraph and writing graph queries in DQL, Dgraph&amp;rsquo;s own graph query language.
Note If you are looking for GraphQL Spec support, please start at https://dgraph.io/docs/graphql/overview/ this tutorial is exclusive for DQL (GraphQL+-).
 The tutorial is divided into modules. You can access the table of contents at any time by clicking on the context menu (&amp;ldquo;sandwich&amp;rdquo; icon) in the bottom left corner of the screen; you can also navigate using the Back and Next buttons at the bottom of this pane, or by pressing your keyboard&amp;rsquo;s Left Arrow (←) and Right Arrow (→) keys.</description>
    </item>
    
    <item>
      <title>Movies Schema</title>
      <link>https://dgraph.io/tour/master/graphqlmoredata/2/</link>
      <pubDate>Mon, 15 May 2017 15:33:51 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlmoredata/2/</guid>
      <description>Given the previous lesson&amp;rsquo;s schema, we have provided you here some example queries to run.
{ queryDirector(filter: { or: [ { name: { allofterms: &amp;quot;Marc Caro&amp;quot; } } { name: { allofterms: &amp;quot;Jean-Pierre Jeunet&amp;quot; } } ]}) { id name films { name } } } { queryGenre(filter: { name: { regexp: &amp;quot;/.*alien.*/i&amp;quot; } }) { name films(first: 2) { name starring { actor { name } character { name } } } } } { queryFilm(filter: { name: { alloftext: &amp;quot;the man runs&amp;quot; } }) { name starringAggregate { count } } } </description>
    </item>
    
    <item>
      <title>Movies Schema</title>
      <link>https://dgraph.io/tour/master/moredata/2/</link>
      <pubDate>Mon, 15 May 2017 15:33:51 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/moredata/2/</guid>
      <description>Dgraph queries, Schema Types and the visualization will help us understand the schema of the movies dataset.
As you&amp;rsquo;ll see in the following pages, we can view the data from a number of perspectives; considering for example directors, movies, genres or even locations as the primary starting point.
Let&amp;rsquo;s have a look from the perspective of directors. Kathryn Bigelow directed the early 90&amp;rsquo;s classic Point Break. We&amp;rsquo;ll begin with her and learn about the schema.</description>
    </item>
    
    <item>
      <title>Some Lines of Data</title>
      <link>https://dgraph.io/tour/master/graphqlsearch/2/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlsearch/2/</guid>
      <description>To better illustrate the following examples, it will help to have some data that contains sentence-length strings.
You will note the presence of a few movie lines to make the examples interesting, along with the the characters and movies associated with these examples.
Run the mutation provided here, and then continue to the next lesson.</description>
    </item>
    
    <item>
      <title>Term search</title>
      <link>https://dgraph.io/tour/master/search/2/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/search/2/</guid>
      <description>With the term index the functions allofterms and anyofterms find strings that match all of the listed terms or any one of the listed terms. Previous queries in the tour used these searches.
Try both options and note the difference.
The query makes no further constraints than requiring the found nodes to have a name matching the terms, so actors and directors are returned.</description>
    </item>
    
    <item>
      <title>Query Variables</title>
      <link>https://dgraph.io/tour/master/blocksvars/2/</link>
      <pubDate>Mon, 01 May 2017 20:46:58 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/2/</guid>
      <description>Results can be stored in variables and used elsewhere in the query.
Variables are declared by
var_name as some_block { ... } where var_name is any distinct variable name and some_block is either a whole query or an internal block of a query matching on an edge.
Once defined, variables can be used in:
 the same query in a child of the defining block (not a parent of the definition) in another query  Variables don&amp;rsquo;t affect the semantics of the query at the point they are defined.</description>
    </item>
    
    <item>
      <title>Adding Data - mutating data</title>
      <link>https://dgraph.io/tour/master/graphqlschema/2/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:47 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlschema/2/</guid>
      <description>Now that you have updated the schema in the previous step, you can use the new mutations created by the GraphQL API to add data. Making changes to the graph stored in a GraphQL dataset is called mutating the data.
If you had a large amount of data to load after updating a GraphQL schema, it might be better to use the Live Loader and add the data as RDF triples.</description>
    </item>
    
    <item>
      <title>Adding Data - mutating data</title>
      <link>https://dgraph.io/tour/master/schema/2/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:47 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/schema/2/</guid>
      <description>Now that the schema has been updated we can add data as triples.
Dgraph creates its own internal id’s for nodes, but we need some way to refer to the same node many times in our input data. That’s what _:company1 does.
Technically, these are ‘blank nodes’. They tell Dgraph to create a node, give it an internal id and make sure it’s used consistently.
After the upload, the label _:company1 doesn’t exist in Dgraph and we can’t query for it.</description>
    </item>
    
    <item>
      <title>Graphs as results</title>
      <link>https://dgraph.io/tour/master/basic/2/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:22 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/2/</guid>
      <description>The last query got us some data, but the result wasn’t very interesting, nor was it much to do with graphs.
In Dgraph and DQL, queries return graphs, not tables or lists of data.
A query is executed against a graph and the result is a subset of the queried graph, or some manipulation or calculation based on the queried graph.
Let’s improve the query to get Michael and his network of friends.</description>
    </item>
    
    <item>
      <title>Graphs as results</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/2/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:22 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/2/</guid>
      <description>The last query returned some data, but the result wasn’t very interesting, nor did it teach us much about graphs.
In Dgraph and GraphQL, queries return graphs, not tables or lists of data.
A query is executed against a graph and the result is a subset of the queried graph.
Let’s improve the query to return Alice, along with her network of friends. Run the query to see the results.</description>
    </item>
    
    <item>
      <title>Run Dgraph</title>
      <link>https://dgraph.io/tour/master/graphqlintro/2/</link>
      <pubDate>Wed, 26 Apr 2017 22:14:20 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlintro/2/</guid>
      <description>You can run an instance of Dgraph on your local supported machine, but to make this tutorial easier to follow along with for all users, we will use Dgraph Cloud.
Dgraph Cloud provides Dgraph database as a managed service, so you can focus on building apps and websites instead of deploying and managing hardware and servers.
Dgraph Cloud offers three service tiers to support your database needs as your database needs grow.</description>
    </item>
    
    <item>
      <title>Run Dgraph</title>
      <link>https://dgraph.io/tour/master/intro/2/</link>
      <pubDate>Wed, 26 Apr 2017 22:14:20 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/intro/2/</guid>
      <description>Let&amp;rsquo;s run an instance of Dgraph on your machine; that&amp;rsquo;ll give you a handle on installing Dgraph and loading data yourself.
All the data in this tutorial will be stored in the instance you install, and all the queries will look for Dgraph on your local machine. By running it in a container, you&amp;rsquo;ll have a fresh Dgraph that will serve as a sandbox for you to learn and experiment.</description>
    </item>
    
    <item>
      <title>Next steps</title>
      <link>https://dgraph.io/tour/master/graphqlmoredata/3/</link>
      <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlmoredata/3/</guid>
      <description>Congratulations on completing the GraphQL tutorial portion of the Dgraph Tour!
You should now be able to load a schema into Dgraph&amp;rsquo;s GraphQL API and perform basic queries and mutations on it.
Where to go from here  Follow the Build a Message Board App in React course to put into application what you have learned. You can find more in-depth details in Dgraph&amp;rsquo;s GraphQL API Documentation. See Deploy and Manage Documentation to learn how you can run Dgraph in your own environment.</description>
    </item>
    
    <item>
      <title>Regular Expressions</title>
      <link>https://dgraph.io/tour/master/search/3/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/search/3/</guid>
      <description>Regular expressions require the trigram index. A trigram is a substring of 3 consecutive characters, or runes.
The trigrams of trigram are: tri, rig, igr, gra and ram.
Valid regular expressions are able to be converted to a trigram query against the index. Dgraph searches the trigram index for possible matches and then runs the full regular expression against the possibles.
Each regular expressions must match at least one trigram.</description>
    </item>
    
    <item>
      <title>Term search</title>
      <link>https://dgraph.io/tour/master/graphqlsearch/3/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlsearch/3/</guid>
      <description>With the term index the functions allofterms and anyofterms find strings that match all of the listed terms or any one of the listed terms. Previous queries in the tour used these searches.
Try both options and note the difference in the query results.</description>
    </item>
    
    <item>
      <title>Query Variables in a child block</title>
      <link>https://dgraph.io/tour/master/blocksvars/3/</link>
      <pubDate>Mon, 01 May 2017 20:47:01 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/3/</guid>
      <description>Query variables in a child block allow the query to carry answers matched at one level down to the children to filter against.
For example, take of the set of actors in all Jane Campion films; our challenge is to find which pairs in that set have acted together on a film not directed by Jane Campion.
The query here uses the sets of all Jane Campion&amp;rsquo;s films JC_films and all actors in any Jane Campion film JC_actors in child blocks.</description>
    </item>
    
    <item>
      <title>External Identifiers</title>
      <link>https://dgraph.io/tour/master/schema/3/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:50 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/schema/3/</guid>
      <description>Dgraph doesn&amp;rsquo;t support setting external IDs for nodes. If an application requires unique identifiers for nodes other than the UIDs assigned by Dgraph, then these have to be supplied as edges. It&amp;rsquo;s up to a user application to ensure the uniqueness of such IDs/keys.
More about in https://dgraph.io/docs/mutations/#external-ids</description>
    </item>
    
    <item>
      <title>Node Identifiers</title>
      <link>https://dgraph.io/tour/master/graphqlschema/3/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:50 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlschema/3/</guid>
      <description>In the last lesson, we mentioned that the Company type doesn&amp;rsquo;t have a unique identifier, so you can&amp;rsquo;t run a pre-built getCompany query or reference a specific company uniquely to create edges to pre-existing nodes.
While this statement was true from the GraphQL API perspective, every node does have a unique identifier (UID) using the ID scalar, even if that identifier is not mapped to a field within the GraphQL schema.</description>
    </item>
    
    <item>
      <title>Data types, Schema and Type System</title>
      <link>https://dgraph.io/tour/master/basic/3/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:41 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/3/</guid>
      <description>It’s time to talk about data types and nodes.
Type System Starting in version 1.1, Dgraph has support for a type system. At the moment, the type system is basic but can be used already to categorize nodes and query them based on their type. The type system is also used during expand queries.
So in order to expand or delete nodes, you need to define your types correctly. You can see more about the Type System here.</description>
    </item>
    
    <item>
      <title>Data types, Schema and Type System</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/3/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:41 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/3/</guid>
      <description>It’s time to talk about data types and scalars.
Type System A GraphQL API is a strictly-typed API. Every node is required to have a specific type. A GraphQL API built with Dgraph does some &amp;ldquo;magic&amp;rdquo; for you so, when you add data it assigns types, and it makes it easy to filter by types when querying data.
You might have noticed from Load Data that the data in triple format includes a predicate for &amp;lt;dgraph.</description>
    </item>
    
    <item>
      <title>Load Schema</title>
      <link>https://dgraph.io/tour/master/graphqlintro/3/</link>
      <pubDate>Wed, 26 Apr 2017 22:28:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlintro/3/</guid>
      <description>Dgraph generates a GraphQL API endpoint complete with CRUD operations after ingesting a GraphQL schema comprised of types. So, when you upload your schema, you already get the ability to perform CRUD operations on instances of each type in your schema, without further coding.
You can copy the schema provided in the editable code block provided here, and then paste it into the Schema input on your Dgraph Cloud instance.</description>
    </item>
    
    <item>
      <title>Load Schema</title>
      <link>https://dgraph.io/tour/master/intro/3/</link>
      <pubDate>Wed, 26 Apr 2017 22:28:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/intro/3/</guid>
      <description>Once you have Dgraph up and running, press run on the panel to the right. This will load a schema into Dgraph for us to use in the first steps of the tutorial. Don&amp;rsquo;t worry too much about the syntax for now, we&amp;rsquo;ll cover all that in later lessons, just check in the response panel that the operation was a success.
Note Note that Schema changes are made via Alter operations only.</description>
    </item>
    
    <item>
      <title>Exact index and inequality</title>
      <link>https://dgraph.io/tour/master/search/4/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/search/4/</guid>
      <description>With the exact index inequalities on strings can be used in filters. Try the query after adding the exact index to the string indexes.
The hash index allows fast filtering for eq on strings.</description>
    </item>
    
    <item>
      <title>Regular Expressions</title>
      <link>https://dgraph.io/tour/master/graphqlsearch/4/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlsearch/4/</guid>
      <description>Regular expressions require the regexp search by directive which applies a trigram index. A trigram is a substring of three consecutive characters, or runes.
The trigrams of &amp;ldquo;trigram&amp;rdquo; are: &amp;ldquo;tri&amp;rdquo;, &amp;ldquo;rig&amp;rdquo;, &amp;ldquo;igr&amp;rdquo;, &amp;ldquo;gra&amp;rdquo; and &amp;ldquo;ram&amp;rdquo;.
Valid regular expressions can be converted to a trigram query against a search index. Dgraph searches the trigram index for possible matches and then runs the full regular expression against the possibles, requiring that at least one matching trigram is found.</description>
    </item>
    
    <item>
      <title>Query Variables in another query block I</title>
      <link>https://dgraph.io/tour/master/blocksvars/4/</link>
      <pubDate>Mon, 01 May 2017 20:48:27 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/4/</guid>
      <description>Let&amp;rsquo;s take a second to think about that last query. The variable JC_actor evaluated to all actors in any Jane Campion film. No matter where we use it, it&amp;rsquo;s the full set.
That&amp;rsquo;s the key to using Dgraph&amp;rsquo;s variables correctly: understand that they are global in the sense that they evaluate to all nodes that could match that edge in the query, not local in the sense that would evaluate to different results for each Jane Campion film.</description>
    </item>
    
    <item>
      <title>Language Support</title>
      <link>https://dgraph.io/tour/master/schema/4/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:50 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/schema/4/</guid>
      <description>Language tags are used on the string on input
_:myID &amp;lt;an_edge&amp;gt; &amp;quot;something&amp;quot;@en . _:myID &amp;lt;an_edge&amp;gt; &amp;quot;某物&amp;quot;@zh-Hans . and on the edge in a query.
You can do the same example using JSON format. You&amp;rsquo;re able to do that through our clients, cURL or Ratel UI.
See the JSON:
 { &amp;quot;set&amp;quot;: [ { &amp;quot;uid&amp;quot;: &amp;quot;_:myID&amp;quot;, &amp;quot;an_edge@en&amp;quot;: &amp;quot;something&amp;quot;, &amp;quot;an_edge@zh-Hans&amp;quot;: &amp;quot;某物&amp;quot; } ] }  Tip The JSON example may end up helping you better understand the format in RDF.</description>
    </item>
    
    <item>
      <title>Reverse edges</title>
      <link>https://dgraph.io/tour/master/graphqlschema/4/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:50 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlschema/4/</guid>
      <description>In Dgraph, edges are directional. A query can&amp;rsquo;t traverse an edge in reverse. Fundamentally, there are two options for querying in both directions:
 Add the reverse edge to the schema and then add all the reverse edge data. Tell Dgraph to always store the reverse edge using the @reverse keyword in the DQL schema. (Not available in the GraphQL schema)  In the generated GraphQL API, Dgraph provides support for the first option with easy-to-use directives.</description>
    </item>
    
    <item>
      <title>Language Support</title>
      <link>https://dgraph.io/tour/master/basic/4/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:45 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/4/</guid>
      <description>Dgraph supports string text and queries as UTF-8.
String valued predicates can be annotated with a language tag.
Amit&amp;rsquo;s name was stored in English &amp;quot;Amit&amp;quot;@en, Hindi &amp;quot;अमित&amp;quot;@hi and Bengali &amp;quot;অমিত&amp;quot;@bn. Michael&amp;rsquo;s was stored in English. Artyom&amp;rsquo;s was stored in English and Russian &amp;quot;Артём&amp;quot;@ru. Sang Hyun&amp;rsquo;s was stored in English and Korean &amp;quot;상현&amp;quot;@ko.
Queries can search over text in the tagged languages by specifying which language to search and which languages to return.</description>
    </item>
    
    <item>
      <title>Queries describe graphs</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/4/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:45 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/4/</guid>
      <description>GraphQL query results are graphs; in fact, the query result is structured like the query.
The braces in a query like &amp;lt;edge name&amp;gt; { ... } signify nested blocks, where the edges inside the block are matched against nodes found by following the edge that begins the block.
We continue nesting the query as we follow edges from node to node. While not strictly required, it’s good style to indent the query.</description>
    </item>
    
    <item>
      <title>Load Data</title>
      <link>https://dgraph.io/tour/master/graphqlintro/4/</link>
      <pubDate>Wed, 26 Apr 2017 22:28:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlintro/4/</guid>
      <description>You can load data into a Dgraph database with GraphQL mutations.
To load the small dataset that we have provided for your use in the upcoming lessons, run the mutations that we have provided by clicking Run.
For the consistency of mutations and queries in this tutorial we use an xid field to identify nodes. We could have not used the xid field and relied solely upon the id field with the scalar type ID, but assigned ids will vary across instances.</description>
    </item>
    
    <item>
      <title>Load Data</title>
      <link>https://dgraph.io/tour/master/intro/4/</link>
      <pubDate>Wed, 26 Apr 2017 22:28:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/intro/4/</guid>
      <description>Now that a schema has been loaded, it&amp;rsquo;s time to load some data. Press the run button again and check that the response panel indicates the data was loaded successfully.
Don&amp;rsquo;t worry about the syntax for now, it will be explained later.
You can load the same example data using JSON format. You&amp;rsquo;re able to do that through our clients, cURL or Ratel UI.
See the JSON:
 Show answer   { &amp;quot;set&amp;quot;: [ { &amp;quot;uid&amp;quot;: &amp;quot;_:michael&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Michael&amp;quot;, &amp;quot;dgraph.</description>
    </item>
    
    <item>
      <title>Query with Reverse Edges</title>
      <link>https://dgraph.io/tour/master/graphqlschema/5/</link>
      <pubDate>Mon, 13 May 2019 23:05:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlschema/5/</guid>
      <description>In the previous lesson, you saw a schema that includes two-way relationships or bidirectional edges. Now, you can run some more advanced queries that use the bidirectional edges that you have set up so far in your database.
With balanced inverse relationships, you can query which company a specific person works for, and also query which employees work at a specific company.
With a data graph that flows in both directions along these bidirectional edges, you can develop a multitude of applications.</description>
    </item>
    
    <item>
      <title>Mutation Introduction</title>
      <link>https://dgraph.io/tour/master/graphqlintro/5/</link>
      <pubDate>Sun, 04 Nov 2018 22:28:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlintro/5/</guid>
      <description>In the last exercise, you added some data into Dgraph. Adding or removing data in Dgraph is called a mutation.
With Dgraph&amp;rsquo;s GraphQL API, every item that is created is called a node. In the previous example we added a total of 11 nodes: eight people and three animals. Nodes can have properties, such as the name and age of the person, and the name of their animal. Nodes can be connected to other nodes by edges.</description>
    </item>
    
    <item>
      <title>Mutation Introduction</title>
      <link>https://dgraph.io/tour/master/intro/5/</link>
      <pubDate>Sun, 04 Nov 2018 22:28:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/intro/5/</guid>
      <description>In the last exercise, you added some data into Dgraph. Adding or removing data in Dgraph is called a mutation. We have two types of standard formats for mutations: RDF (Resource Description Framework) N-Quad and JSON (JavaScript Object Notation). RDF is a widely used standard in Graph or Ontology systems.
In Dgraph the mutation operations consist of two patterns: blank UID reference or explicit UID reference.
This introduction is important for the coming exercises, many of the concepts presented here will be repeated in the next few chapters.</description>
    </item>
    
    <item>
      <title>Exact index and inequality</title>
      <link>https://dgraph.io/tour/master/graphqlsearch/5/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlsearch/5/</guid>
      <description>With the exact index, inequalities on strings can be used in filters. Try running the query shown here to return lines that are alphabetically between &amp;ldquo;I&amp;rdquo; and &amp;ldquo;J&amp;rdquo;.
The hash index lets you quickly filter for eq (equality) on strings.</description>
    </item>
    
    <item>
      <title>Full Text Search</title>
      <link>https://dgraph.io/tour/master/search/5/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/search/5/</guid>
      <description>Full text search is what Google does for web pages. It&amp;rsquo;s different to term matching because it tries to respect language, grammar and tense. For example, matching search term run with documents containing run, running and ran.
It doesn&amp;rsquo;t match terms exactly and instead makes use of
 stemming : finding a common base word so differences in tense, plural/singular or other inflection are still matched, and stop words : removing words such as and, or, it and maybe that occur too often to search over.</description>
    </item>
    
    <item>
      <title>Query Variables in another query block II</title>
      <link>https://dgraph.io/tour/master/blocksvars/5/</link>
      <pubDate>Mon, 01 May 2017 20:48:30 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/5/</guid>
      <description>Query variables used in other query blocks also allow to reorganize results.</description>
    </item>
    
    <item>
      <title>Reverse edges</title>
      <link>https://dgraph.io/tour/master/schema/5/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:50 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/schema/5/</guid>
      <description>Edges are directional. A query can&amp;rsquo;t traverse an edge in reverse.
There are two choices to query in both directions
  Add the reverse edge to the schema and add all the reverse edge data.
  Tell Dgraph to always store the reverse edge using the @reverse keyword in the schema.
  Run the schema mutation and Dgraph will compute all the reverse edges. The reverse edge of an_edge is ~an_edge.</description>
    </item>
    
    <item>
      <title>Functions and filtering</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/5/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:47 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/5/</guid>
      <description>Nodes are filtered based on functions applied to the node&amp;rsquo;s outgoing edges.
So far, the queries have only applied a filter to the top level nodes using the getPerson function, but you can apply filters to any edge in the query.
Dgraph has many functions available for filtering results, including the following:
  fieldName: { allofterms: &amp;quot;term1 ... termN&amp;quot; }: matches nodes with an outgoing string field fieldName where the string contains all listed terms</description>
    </item>
    
    <item>
      <title>Queries describe graphs</title>
      <link>https://dgraph.io/tour/master/basic/5/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:45 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/5/</guid>
      <description>Dgraph query results are graphs. In fact, the result structure matches the query structure.
The braces edge_name { ... } in the query signify nested blocks where the edges inside the block are matched against nodes found by following the edge that begins the block. We continue nesting the query as we follow edges from node to node.
While not strictly required, it’s a good style to indent the query.</description>
    </item>
    
    <item>
      <title>Reverse edges Query</title>
      <link>https://dgraph.io/tour/master/schema/6/</link>
      <pubDate>Mon, 13 May 2019 23:05:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/schema/6/</guid>
      <description>The reverse edge of anEdge is ~anEdge.
In this query we want to know who works for &amp;ldquo;CompanyABC&amp;rdquo; without having to add extra edges. So we use a reverse edge for the specific case. And then we use an alias &amp;ldquo;work_here&amp;rdquo; to differentiate the query result.</description>
    </item>
    
    <item>
      <title>Full Text Search : language support</title>
      <link>https://dgraph.io/tour/master/search/6/</link>
      <pubDate>Mon, 15 May 2017 15:32:13 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/search/6/</guid>
      <description>Full text search works only for languages for which there are stemming procedures and stop word lists.
Currently, Dgraph supports
   Language Country Code     Danish da   Dutch nl   English en   Finnish fi   French fr   German de   Hungarian hu   Italian it   Norwegian no   Portuguese pt   Romanian ro   Russian ru   Spanish es   Swedish sv   Turkish tr   Chinese zh   Japanese ja   Korean ko    </description>
    </item>
    
    <item>
      <title>Full Text Search</title>
      <link>https://dgraph.io/tour/master/graphqlsearch/6/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlsearch/6/</guid>
      <description>Full text search is what Google and other search engines do for web pages. It&amp;rsquo;s different than term matching because it factors in language, grammar, and tense. For example, you will see matches on the search keyword &amp;ldquo;run&amp;rdquo; with documents that contain very common strings like &amp;ldquo;run&amp;rdquo;, &amp;ldquo;running&amp;rdquo; and &amp;ldquo;ran&amp;rdquo;.
Full text search does not match terms exactly, but instead makes use of the following techniques:
 Stemming: finding a common base word so differences in tense, plural/singular or other inflection don&amp;rsquo;t prevent a match, and Stop words: removing common words such as &amp;ldquo;and&amp;rdquo;, &amp;ldquo;or&amp;rdquo;, &amp;ldquo;it&amp;rdquo;; along with some additional words that occur too often.</description>
    </item>
    
    <item>
      <title>Exercise: Query Variables linking queries</title>
      <link>https://dgraph.io/tour/master/blocksvars/6/</link>
      <pubDate>Mon, 01 May 2017 20:48:32 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/6/</guid>
      <description>We&amp;rsquo;ve seen two common uses for variables: filtering and reorganizing results. Another is linking two queries to gain some new insight based on the joined results.
Let&amp;rsquo;s look at an example of joining two queries.
For two directors find the actors who have worked with both (not necessarily on the same movie). Many directors won&amp;rsquo;t have actors in common, so start with some you are sure will (the answer below uses Peter Jackson and Martin Scorsese who have a small number of actors in common).</description>
    </item>
    
    <item>
      <title>Exercise: Integrating existing data</title>
      <link>https://dgraph.io/tour/master/graphqlschema/6/</link>
      <pubDate>Mon, 01 May 2017 10:41:33 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlschema/6/</guid>
      <description>In previous lessons, you added a new schema and loaded some company data. But, what about integrating the pre-existing dataset about friends and their pets with the dataset extension that includes companies?
If we try to reference an existing company in a mutation by name with our current schema, we will instead create a new Company node, as you saw in a previous lesson. The generated GraphQL API makes it very easy to search for a node to update, and update the node linking to existing or new nodes.</description>
    </item>
    
    <item>
      <title>Logical Connectives (and, or, &amp; not)</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/6/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:51 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/6/</guid>
      <description>The logical connectives and, or and not combine multiple functions in a filter.
When you provide multiple parameters in a filter argument they are combined with and logic by default, as in the following example:
{ getPerson(xid: &amp;quot;alice&amp;quot;) { xid friends(filter: { xid: { eq: &amp;quot;dave&amp;quot; } age: { eq: 35 } }) { xid age } } } With GraphQL, each parameter of an argument object must be unique. You can wrap arguments in logical lists using and and or, as follows:</description>
    </item>
    
    <item>
      <title>Functions and filtering</title>
      <link>https://dgraph.io/tour/master/basic/6/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:47 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/6/</guid>
      <description>Nodes are filtered based on functions applied to the node&amp;rsquo;s outgoing edges.
So far the queries have only applied a filter to the top level nodes, but filters can be applied to any node in the query.
Note the syntax difference between filtering at the root of a query and filtering on internal blocks.
There are many functions for filtering, some of them are
  allOfTerms(edge_name, &amp;quot;term1 ... termN&amp;quot;): matches nodes with an outgoing string edge edge_name where the string contains all listed terms.</description>
    </item>
    
    <item>
      <title>Graphs</title>
      <link>https://dgraph.io/tour/master/graphqlintro/6/</link>
      <pubDate>Wed, 26 Apr 2017 22:28:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlintro/6/</guid>
      <description>So far in this tour, you have deployed a Dgraph Cloud backend and run a few mutations to edit data. But before proceeding further, you&amp;rsquo;d probably like to understand some basics, like: What is a graph, and what does it have to do with databases?
Graphs describe objects and the interconnections between them. You may have heard of friendship or social network graphs, where data points (people) are connected together through known relationships.</description>
    </item>
    
    <item>
      <title>Graphs</title>
      <link>https://dgraph.io/tour/master/intro/6/</link>
      <pubDate>Wed, 26 Apr 2017 22:28:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/intro/6/</guid>
      <description>We&amp;rsquo;ve started Dgraph, but first things first: What is a graph and what has that got to do with databases?
Graphs describe objects and the interconnections among them. Many people have heard of friendship graphs, or social network graphs, so let’s start there.
We have loaded Ratel UI in an iFrame for this lesson and have ran the following query against your endpoint you provided in the earlier lesson.
 Show answer  { michael(func: anyofterms(name, &amp;quot;Michael&amp;quot;)) { name owns_pet { name } friend { name friend { expand(_all_) { expand(_all_) } } owns_pet { name } } } }    In the resulting graph, circles denote people and pets, and lines denote connections or labeled relationships among them.</description>
    </item>
    
    <item>
      <title>Congratulations</title>
      <link>https://dgraph.io/tour/master/graphqlsearch/7/</link>
      <pubDate>Mon, 15 May 2017 15:32:26 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlsearch/7/</guid>
      <description>You’ve finished this module!
You can use what you learned in this module to search GraphQL datasets.
Check out the list of sections again, go back and review anything that wasn&amp;rsquo;t clear, or continue to the next module.</description>
    </item>
    
    <item>
      <title>Geo queries : Near</title>
      <link>https://dgraph.io/tour/master/search/7/</link>
      <pubDate>Mon, 15 May 2017 15:32:26 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/search/7/</guid>
      <description>Coming soon.</description>
    </item>
    
    <item>
      <title>Value variables - min and max</title>
      <link>https://dgraph.io/tour/master/blocksvars/7/</link>
      <pubDate>Tue, 02 May 2017 11:01:04 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/7/</guid>
      <description>We&amp;rsquo;ve just looked at variables that stored uid results from query blocks. Value variables store the values against which they match.
Value variables work differently to query variables. Value variables are context dependent - in fact, they are a map from UID to value and we can exploit this when reading and filtering value variables. The value from a value variable is extracted with val(&amp;lt;variable-name&amp;gt;).
At the point of definition, because the context is within the appropriate UID, value variables act like the corresponding value.</description>
    </item>
    
    <item>
      <title>Exercise : Integrating existing data</title>
      <link>https://dgraph.io/tour/master/schema/7/</link>
      <pubDate>Mon, 01 May 2017 10:41:33 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/schema/7/</guid>
      <description>We&amp;rsquo;ve added a new schema and loaded some company data, but what about integrating our previous friends dataset with this company one.
Trying to use the blank nodes from previous mutations won&amp;rsquo;t work. The blank nodes aren&amp;rsquo;t persisted in the store, so when referring to nodes created in a previous mutation, it&amp;rsquo;s the UID that&amp;rsquo;s needed. So instead of
_:sarah &amp;lt;works_for&amp;gt; _:company1 . it&amp;rsquo;s
&amp;lt;uid_of_sarah&amp;gt; &amp;lt;works_for&amp;gt; &amp;lt;uid_of_company1&amp;gt; . Because the uid picked by Dgraph is unique, we can&amp;rsquo;t help you this time.</description>
    </item>
    
    <item>
      <title>Deleting Data</title>
      <link>https://dgraph.io/tour/master/graphqlschema/7/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:53 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlschema/7/</guid>
      <description>Dgraph&amp;rsquo;s generated GraphQL API also provides mutations to delete data from the graph. Data can be deleted in the following ways:
 Update nodes and remove edges Update nodes and remove predicate values Delete a node with all of its inbound and outbound edges and predicate values.  To remove an edge from a node, you will need to use the same update mutation pattern that you saw in the previous lesson.</description>
    </item>
    
    <item>
      <title>Sort Query Results</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/7/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:34 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/7/</guid>
      <description>You can sort (or order) query results by using the order argument on edges and query&amp;lt;Type&amp;gt; query functions.
When you apply ordering, the visualization of the graph remains unchanged, but the JSON response returned contains an ordered list.
The generated &amp;lt;type&amp;gt;Order input type accepts three arguments:
 asc - Sort by a field in ascending order desc - Sort by a field in descending order, and then - Add an additional sort argument.</description>
    </item>
    
    <item>
      <title>AND, OR and NOT</title>
      <link>https://dgraph.io/tour/master/basic/7/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:51 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/7/</guid>
      <description>The logical connectives AND, OR and NOT combine multiple functions in a filter.</description>
    </item>
    
    <item>
      <title>Graph Databases</title>
      <link>https://dgraph.io/tour/master/graphqlintro/7/</link>
      <pubDate>Wed, 26 Apr 2017 22:28:58 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlintro/7/</guid>
      <description>A graph database is a database optimized for storing and querying graphs. When it comes to relationships, graph databases are much faster than SQL databases.
SQL databases get bogged down by graph-like data because following edges means joining tables; sometimes big tables. And, the more edges, the more joins, and the more data needs to be loaded and processed.
In a graph database, the edges are a fundamental structure, so following edges occurs in a single lookup making edge-based operations blazingly fast.</description>
    </item>
    
    <item>
      <title>Graph Databases</title>
      <link>https://dgraph.io/tour/master/intro/7/</link>
      <pubDate>Wed, 26 Apr 2017 22:28:58 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/intro/7/</guid>
      <description>A graph database is a database optimized for storing and querying graphs. When it comes to relationships, graph databases are much faster than SQL databases.
SQL databases get bogged down by graph-like data because following edges means joining tables; sometimes big tables; the more edges, the more joins, and the more data needs to be loaded and processed.
In a graph database, the edges are a fundamental structure, so following edges is a single lookup, making this operation blazingly fast.</description>
    </item>
    
    <item>
      <title>Next steps</title>
      <link>https://dgraph.io/tour/master/search/8/</link>
      <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://dgraph.io/tour/master/search/8/</guid>
      <description>Congratulations on completing the Tour!
You should now be able to load data into Dgraph and perform basic queries and mutations on it.
Where to go from here  Follow the Tutorial videos to reinforce what you have learnt. More queries can be found in the Query Language reference. Go to Clients to see how to communicate with Dgraph from your application. See Deploy if you wish to run Dgraph in a cluster.</description>
    </item>
    
    <item>
      <title>Exercise : Value variables - sum and avg</title>
      <link>https://dgraph.io/tour/master/blocksvars/8/</link>
      <pubDate>Tue, 02 May 2017 11:01:06 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/8/</guid>
      <description>Summation sum and average avg can only be applied to value variables that contain int and float data.
Find which is greater, the number of movies by Steven Spielberg or the average number of actors in movies directed by him.
This query can be done in a single block, but you&amp;rsquo;ll see here how values are available in other blocks if the corresponding UID&amp;rsquo;s are available for the value map.</description>
    </item>
    
    <item>
      <title>Congratulations</title>
      <link>https://dgraph.io/tour/master/graphqlschema/8/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlschema/8/</guid>
      <description>Congratulations on completing the schema module.
The Dgraph instance you have running for the tutorial and the lessons in the modules so far give you a sandbox to play in. Make whatever queries or changes you like until you are comfortable with the material covered so far.
When you&amp;rsquo;re done, let&amp;rsquo;s move on to learning about the search capabilities of Dgraph&amp;rsquo;s generated GraphQL API. Then, you can delve into some larger datasets with GraphQL before taking a look at DQL, Dgraph&amp;rsquo;s query language.</description>
    </item>
    
    <item>
      <title>Deleting Data</title>
      <link>https://dgraph.io/tour/master/schema/8/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:53 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/schema/8/</guid>
      <description>There are three deletion options inside a delete mutation.
 &amp;lt;uid&amp;gt; &amp;lt;edge&amp;gt; &amp;lt;uid&amp;gt;/&amp;quot;value&amp;quot; . Delete a single triple &amp;lt;uid&amp;gt; &amp;lt;edge&amp;gt; * . Delete all triples for a given edge &amp;lt;uid&amp;gt; * * . Delete all triples for a given node  The examples given here are not complete. Uids assigned on your instance would be unique. Try something out; you&amp;rsquo;re not going to hurt anyone, just delete their friends.
You can do the same example using JSON format.</description>
    </item>
    
    <item>
      <title>Pagination (first and offset)</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/8/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:36 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/8/</guid>
      <description>It&amp;rsquo;s not uncommon to have thousands of results for a query.
But you might want to paginate the results for display, or limit a large result set.
Dgraph generates first and offset arguments that can be used in combination to achieve such limits and paginate results:
 first: N Return only the first N results offset: N Skip the first N results  By default, query answers are ordered by uid.</description>
    </item>
    
    <item>
      <title>Sorting (orderasc or orderdesc)</title>
      <link>https://dgraph.io/tour/master/basic/8/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:34 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/8/</guid>
      <description>Results can be ordered using orderasc and orderdesc.
The visualization will look the same as without the sorting, but the JSON result is ordered.</description>
    </item>
    
    <item>
      <title>Congratulations</title>
      <link>https://dgraph.io/tour/master/intro/8/</link>
      <pubDate>Wed, 26 Apr 2017 22:29:00 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/intro/8/</guid>
      <description>Congratulations, you&amp;rsquo;ve finished the first module of the tutorial.
By now you should have Dgraph up and running for the tutorial and know a little about graphs.
Let’s investigate some graphs and start writing queries.</description>
    </item>
    
    <item>
      <title>GraphQL API</title>
      <link>https://dgraph.io/tour/master/graphqlintro/8/</link>
      <pubDate>Wed, 26 Apr 2017 22:29:00 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlintro/8/</guid>
      <description>Dgraph at its core is a loosely-typed database, and can be used in a NoSQL-like schema-less fashion. GraphQL provides a strongly typed API that is served from the core of a Dgraph database instance.
All other GraphQL databases apply GraphQL as a layer served above the database, but starting with Dgraph 20.03, Dgraph brings GraphQL into the core of the database itself. Dgraph was developed around DQL&amp;rsquo;s GraphQL-like syntax, so integrating native GraphQL was a natural fit.</description>
    </item>
    
    <item>
      <title>Value variables: filtering and ordering</title>
      <link>https://dgraph.io/tour/master/blocksvars/9/</link>
      <pubDate>Tue, 02 May 2017 11:01:09 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/9/</guid>
      <description>If the context provided by the UIDs of the block is correct, value variables can also be used in filtering and ordering.
Here, ID will be the UID&amp;rsquo;s of all directors of name Steven and average is a map from those UID&amp;rsquo;s to the average for each director. The filtering, ordering and result for var(average) are evaluated in that context to obtain each value.
A value variable can be used in place of a UID variable, uid(&amp;lt;value-variable&amp;gt;) evaluates to the UID&amp;rsquo;s in the map.</description>
    </item>
    
    <item>
      <title>Expand Predicate</title>
      <link>https://dgraph.io/tour/master/schema/9/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/schema/9/</guid>
      <description>expand(...predicates...) is used to query for all given predicates, rather than listing them in the query. Querying
expand(_all_) queries returns all edges out of every node matched at that level in the query. Expand can be nested to then expand all predicates at the next level.
We&amp;rsquo;ll see later how to use expand with variables to query for a particular set of edges.
Note As of version v1.1 you will need to add Types in your schema for expand(_all_) to work.</description>
    </item>
    
    <item>
      <title>Count</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/9/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:40 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/9/</guid>
      <description>You may have noticed that Dgraph generates an &amp;lt;edgeName&amp;gt;Aggregate edge for every edge pointing to a list. These aggregate edges, along with aggregate queries, allow you to count the number of items in a query without the need to return every node.
These aggregate operations return an aggregate result type generated as &amp;lt;type&amp;gt;AggregateResult. This type provides a unique set of fields for counting and finding the minimum, maximum, average, and sum values depending on the types in the schema.</description>
    </item>
    
    <item>
      <title>Pagination (first, offset and after)</title>
      <link>https://dgraph.io/tour/master/basic/9/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:36 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/9/</guid>
      <description>It&amp;rsquo;s not uncommon to have thousands of results for a query.
But you might want to select only the top-k answers, paginate the results for display, or limit a large result.
In DQL this is done with first, offset and after in combination with ordering.
 first: N Return only the first N results offset: N Skip the first N results after: uid Return the results after uid  By default, query answers are ordered by uid.</description>
    </item>
    
    <item>
      <title>Congratulations</title>
      <link>https://dgraph.io/tour/master/graphqlintro/9/</link>
      <pubDate>Wed, 26 Apr 2017 22:29:00 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlintro/9/</guid>
      <description>Congratulations, you&amp;rsquo;ve finished the first module of the tutorial! By now, you should have seen an example mutation and query, and know a little about graphs.
Let&amp;rsquo;s investigate some graphs and start writing more queries!</description>
    </item>
    
    <item>
      <title>Value variables: math functions</title>
      <link>https://dgraph.io/tour/master/blocksvars/10/</link>
      <pubDate>Tue, 02 May 2017 11:01:09 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/10/</guid>
      <description>As well as min, max, avg, and sum to aggregate, Dgraph supports a host of functions that can be applied to value variables. These need to be enclosed in math(...) and stored in a variable.
The full list is:
   Operator Accepted Type Notes     + - * / % int and float    min max All types except geo and bool    &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= == !</description>
    </item>
    
    <item>
      <title>How Dgraph Search Works</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/10/</link>
      <pubDate>Mon, 01 May 2017 11:55:43 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/10/</guid>
      <description>Given what you&amp;rsquo;ve seen so far, you&amp;rsquo;ve probably already understood this, but it&amp;rsquo;s worth going over.
The graphs in Dgraph can be huge, so starting your search from all nodes isn&amp;rsquo;t always efficient. Dgraph needs a place to start searching, and you choose this by starting your search from a root query function.
For example, you can use the root query functions with names like query&amp;lt;type&amp;gt; or get&amp;lt;type&amp;gt; to find an initial set of nodes.</description>
    </item>
    
    <item>
      <title>Congratulations</title>
      <link>https://dgraph.io/tour/master/schema/10/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/schema/10/</guid>
      <description>This is the end of the schema module.
The Dgraph instance you have running for the tutorial and the lessons in the modules so far give you a sandbox to play in. Make whatever queries or changes you like until you are comfortable with the material covered so far.
When you&amp;rsquo;re done, let&amp;rsquo;s move up to bigger datasets and see more of Dgraph&amp;rsquo;s query language.</description>
    </item>
    
    <item>
      <title>Count</title>
      <link>https://dgraph.io/tour/master/basic/10/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:40 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/10/</guid>
      <description>The number of outgoing edges can be counted, using the count function.</description>
    </item>
    
    <item>
      <title>Exercise : Latest Movies</title>
      <link>https://dgraph.io/tour/master/blocksvars/11/</link>
      <pubDate>Tue, 02 May 2017 11:01:12 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/11/</guid>
      <description>Write a query to find the most recently released movie by each director and order the result by the release dates.
If you need some hints try:  Show answer  To solve this, you&amp;rsquo;ll need to
 work out how to query for all directors - what have directors done that make them directors? find the most recent release date for each director sort the results by the most recent release return the directors name, and the details of the most recent release you&amp;rsquo;ll need one query to get the directors and their latest movies, and another query to sort this to get most recent movies first for something extra, try using since to work out how many days since the movie was released (or how many days till release, for some)    Spoiler alert:  Show answer  { # Get all directors var(func: has(director.</description>
    </item>
    
    <item>
      <title>How Dgraph Search Works</title>
      <link>https://dgraph.io/tour/master/basic/11/</link>
      <pubDate>Mon, 01 May 2017 11:55:43 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/11/</guid>
      <description>Given what you&amp;rsquo;ve seen so far, you&amp;rsquo;ve probably already understood this, but it&amp;rsquo;s worth going over.
The graphs in Dgraph can be huge, so starting searching from all nodes isn&amp;rsquo;t efficient. Dgraph needs a place to start searching, that&amp;rsquo;s the root node.
At root, we use func: and a function to find an initial set of nodes. So far we&amp;rsquo;ve used eq and allofterms for string search, but we can also search on other values like dates, numbers, and also filters on count.</description>
    </item>
    
    <item>
      <title>The has Function</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/11/</link>
      <pubDate>Mon, 01 May 2017 11:55:43 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/11/</guid>
      <description>The function has(edge_name) returns nodes that have an outgoing edge of the given name.
Dgraph also provides the filter argument has to find nodes that have an outgoing edge or predicate value.
The query example provided here queries for all people who have friends and then returns a count of how many friends they have.
Something to try: Query people that have friends and an age, and then count their friends that have a set age.</description>
    </item>
    
    <item>
      <title>GroupBy</title>
      <link>https://dgraph.io/tour/master/blocksvars/12/</link>
      <pubDate>Tue, 02 May 2017 11:01:12 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/12/</guid>
      <description>A groupby query aggregates query results given a set of properties on which to group elements. For example, a query containing the block
director.film @groupby(genre) { a as count(uid) } finds nodes reachable along the director.film edge, partitions these into groups based on genre, then counts how many nodes are in each group.
Inside a groupby block, only aggregations are allowed and count can only be applied to uid.
The result is the grouped edges and the value variables for the aggregations.</description>
    </item>
    
    <item>
      <title>Aliases</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/12/</link>
      <pubDate>Mon, 01 May 2017 11:55:43 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/12/</guid>
      <description>The output graph can rename fields in the output using aliases.
Aliases are useful when you want to apply two different filters to the same edge. The example query that&amp;rsquo;s provided for you in the editor uses aliases to include the friends edge twice, with a unique set of arguments and fields in each case.
Something to try: Query People, then select and alias the xid field as username and alias the query as users.</description>
    </item>
    
    <item>
      <title>Has</title>
      <link>https://dgraph.io/tour/master/basic/12/</link>
      <pubDate>Mon, 01 May 2017 11:55:43 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/12/</guid>
      <description>The function has(edge_name) returns nodes that have an outgoing edge of the given name.</description>
    </item>
    
    <item>
      <title>Congratulations!</title>
      <link>https://dgraph.io/tour/master/blocksvars/13/</link>
      <pubDate>Tue, 02 May 2017 11:01:12 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/blocksvars/13/</guid>
      <description>You&amp;rsquo;ve finished this lesson.
Next up, string and geo searching. Or use the index to go to another topic.</description>
    </item>
    
    <item>
      <title>Cascade</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/13/</link>
      <pubDate>Mon, 01 May 2017 11:55:46 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/13/</guid>
      <description>The @cascade directive removes any nodes from query results that don&amp;rsquo;t have all fields included in the query. You can also use the @cascade directive to remove nodes from query results where a filter inside a block returns no results.
In the following query, Dgraph returns all of Alice&amp;rsquo;s friends, whether or not they own a pet:
{ getPerson(xid: &amp;quot;alice&amp;quot;) { name age friends { name ownsPets { name } } } } With the @cascade directive, friends of Alice that don&amp;rsquo;t own a pet are not included in the result, as follows:</description>
    </item>
    
    <item>
      <title>Alias</title>
      <link>https://dgraph.io/tour/master/basic/13/</link>
      <pubDate>Mon, 01 May 2017 11:55:43 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/13/</guid>
      <description>The output graph can set names for edges in the output with aliasing.</description>
    </item>
    
    <item>
      <title>Cascade</title>
      <link>https://dgraph.io/tour/master/basic/14/</link>
      <pubDate>Mon, 01 May 2017 11:55:46 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/14/</guid>
      <description>The @cascade directive removes any nodes that don&amp;rsquo;t have all matching edges in the query.
Another use is to remove nodes where a filter inside a block returns no results.
In the query below, Dgraph returns all Michael&amp;rsquo;s friends, whether or not they own a pet.
{ michael_friends_with_pets(func: allofterms(name@., &amp;quot;Michael&amp;quot;)) { name age friend { name@. owns_pet } } } With the @cascade directive, friends of Michael that don&amp;rsquo;t own a pet are not included in the result.</description>
    </item>
    
    <item>
      <title>Comments</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/14/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/14/</guid>
      <description>Queries can contain comments.
Anything after a hash (#) on a line is a comment, and ignored for query processing.
This is helpful for debugging queries and for tutorials that need to explain parts of queries in-line, which is what we&amp;rsquo;ll do for the more complex queries that you&amp;rsquo;ll encounter later in the tutorial.</description>
    </item>
    
    <item>
      <title>Normalize</title>
      <link>https://dgraph.io/tour/master/basic/15/</link>
      <pubDate>Mon, 01 May 2017 11:55:49 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/15/</guid>
      <description>The @normalize directive
  returns only edges listed with an alias, and
  flattens the result to remove nesting
  Tip Aliased names can be the same as the original edge.
 </description>
    </item>
    
    <item>
      <title>Congratulations</title>
      <link>https://dgraph.io/tour/master/graphqlbasic/15/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/graphqlbasic/15/</guid>
      <description>You’ve finished this module!
You can use what you learned in this module to query graphs, filter the output, and sort and paginate the results using the generated GraphQL API provided by Dgraph.
Check out the list of sections again, go back and review anything that wasn&amp;rsquo;t clear, or continue to the next module.</description>
    </item>
    
    <item>
      <title>Comments</title>
      <link>https://dgraph.io/tour/master/basic/16/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/16/</guid>
      <description>Queries can contain comments.
Anything after # on a line is a comment and ignored for query processing.
This is helpful for debugging queries and for tutorials that need to explain parts of queries in-line, which is what we&amp;rsquo;ll do for the more complex queries you&amp;rsquo;ll encounter later in the tutorial.</description>
    </item>
    
    <item>
      <title>Facets : Edge attributes</title>
      <link>https://dgraph.io/tour/master/basic/17/</link>
      <pubDate>Mon, 17 Sep 2018 16:11:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/17/</guid>
      <description>Dgraph supports facets — key value pairs on edges — as an extension to RDF triples. That is, facets add properties to edges, rather than to nodes. For example, a friend edge between two nodes may have a boolean property of close friendship. Facets can also be used as weights for edges.
More details about Facets you can find in our Docs: https://dgraph.io/docs/query-language/#facets-edge-attributes
Reading all the documentation about Facets you will have examples of:</description>
    </item>
    
    <item>
      <title>Congratulations</title>
      <link>https://dgraph.io/tour/master/basic/18/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/master/basic/18/</guid>
      <description>You’ve finished the lesson.
You can use the material in this lesson to query graphs, filter the output, and sort and paginate the results.
Check out the list of sections again, go back and review anything that wasn&amp;rsquo;t clear, or go on with the next lesson.</description>
    </item>
    
  </channel>
</rss>
