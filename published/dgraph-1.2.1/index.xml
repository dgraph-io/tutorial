<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>A Tour of Dgraph</title>
    <link>https://dgraph.io/tour/dgraph-1.2.1/</link>
    <description>Recent content on A Tour of Dgraph</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 13 May 2019 23:05:55 +1000</lastBuildDate>
    
	<atom:link href="https://dgraph.io/tour/dgraph-1.2.1/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Indexes</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/search/1/</link>
      <pubDate>Mon, 15 May 2017 15:31:59 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/search/1/</guid>
      <description>When Dgraph is searching for strings, dates, or other values based on a filter, it needs an index to make the search efficient. We&amp;rsquo;ve already seen examples of how to specify the indexes in a schema mutation.
int, float, geo and date have default indexes, but string has options of what index types to choose. Multiple indexes can be built for the same string valued predicate.
For string the following indexes are available</description>
    </item>
    
    <item>
      <title>Multiple Named Query Blocks</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/1/</link>
      <pubDate>Mon, 01 May 2017 13:45:26 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/1/</guid>
      <description>Note From now on, to run the queries, you&amp;rsquo;ll need to have loaded the million triple movie dataset.
 Queries can be issued as multiples.
For queries labelled q1, ..., qn issued as a multiple query block, the JSON result will contain labelled answer blocks q1, ..., qn for each query.
If a block is labelled with var, no results are returned for that query.
Queries issued in this way are independent.</description>
    </item>
    
    <item>
      <title>A bigger dataset</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/aggregation/1/</link>
      <pubDate>Thu, 27 Apr 2017 15:42:54 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/aggregation/1/</guid>
      <description>Ok, we are off to a start with Dgraph and GraphQL+-. Let’s move it up a few notches.
Dgraph can also do query aggregation, geo-queries, string querying and more. But for all that let&amp;rsquo;s move from the small datasets we started with and try out something bigger, much bigger.
In our github repository you&amp;rsquo;ll find a dataset about movies, directors and actors.
Download it from that link or with something like</description>
    </item>
    
    <item>
      <title>A bigger dataset</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/moredata/1/</link>
      <pubDate>Thu, 27 Apr 2017 15:42:54 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/moredata/1/</guid>
      <description>Ok, we are off to a start with Dgraph and GraphQL+-. Let’s move it up a few notches.
Dgraph can also do query aggregation, geo-queries, string querying and more. But for all that let&amp;rsquo;s move from the small datasets we started with and try out something bigger, much bigger.
In our github repository you&amp;rsquo;ll find a dataset about movies, directors and actors.
Download it from that link and save into the ~/dgraph directory or by running the following in a terminal</description>
    </item>
    
    <item>
      <title>Hello World</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/1/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:18 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/1/</guid>
      <description>Note For the following queries to run, you should have loaded data in the introduction.
 Let’s have a look at a hello world query in GraphQL+-.
Every query has a name, and the result is labelled with the same name.
The search criteria func: ... matches nodes. Function eq does what you&amp;rsquo;d expect, matching nodes with a name equalling &amp;ldquo;Michael&amp;rdquo;. The result is the matched nodes and listed outgoing edges from those nodes.</description>
    </item>
    
    <item>
      <title>Adding schema - mutating schema</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/schema/1/</link>
      <pubDate>Wed, 26 Apr 2017 21:53:48 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/schema/1/</guid>
      <description>As we saw in an earlier lesson, Dgraph stores a schema describing the types of predicates.
When we want to add new data to an existing schema, we can just add it. But if we want to add new data in a new schema we have two choices
 Add the data and let Dgraph work out the schema, or Specify a schema and then add the data  Dgraph can work out the schema just fine.</description>
    </item>
    
    <item>
      <title>Welcome</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/intro/1/</link>
      <pubDate>Wed, 26 Apr 2017 21:52:39 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/intro/1/</guid>
      <description>Hi,
Welcome to Dgraph.
This interactive tutorial will get you up and running with Dgraph and writing graph queries in GraphQL+-, Dgraph&amp;rsquo;s own graph query language.
The tutorial is divided into modules. You can access the table of contents at any time by clicking &amp;ldquo;A Tour of Dgraph&amp;rdquo; in the top left and can move backwards and forwards using the right and left arrows at the bottom of this pane.</description>
    </item>
    
    <item>
      <title>Movies Schema</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/moredata/2/</link>
      <pubDate>Mon, 15 May 2017 15:33:51 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/moredata/2/</guid>
      <description>Dgraph queries, Schema Types and the visualization will help us understand the schema of the movies dataset.
As you&amp;rsquo;ll see in the following pages, we can view the data from a number of perspectives; considering for example directors, movies, genres or even locations as the primary starting point.
Let&amp;rsquo;s have a look from the perspective of directors. Kathryn Bigelow directed the early 90&amp;rsquo;s classic Point Break. We&amp;rsquo;ll begin with her and learn about the schema.</description>
    </item>
    
    <item>
      <title>Term search</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/search/2/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/search/2/</guid>
      <description>With the term index the functions allofterms and anyofterms find strings that match all of the listed terms or any one of the listed terms. Previous queries in the tour used these searches.
Try both options and note the difference.
The query makes no further constraints than requiring the found nodes to have a name matching the terms, so actors and directors are returned.</description>
    </item>
    
    <item>
      <title>Query Variables</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/2/</link>
      <pubDate>Mon, 01 May 2017 20:46:58 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/2/</guid>
      <description>Results can be stored in variables and used elsewhere in the query.
Variables are declared by
var_name as some_block { ... } where var_name is any distinct variable name and some_block is either a whole query or an internal block of a query matching on an edge.
Once defined, variables can be used in:
 the same query in a child of the defining block (not a parent of the definition) in another query  Variables don&amp;rsquo;t affect the semantics of the query at the point they are defined.</description>
    </item>
    
    <item>
      <title>Adding Data - mutating data</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/schema/2/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:47 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/schema/2/</guid>
      <description>Now that the schema has been updated we can add data as triples.
Dgraph creates its own internal id’s for nodes, but we need some way to refer to the same node many times in our input data. That’s what _:company1 does.
Technically, these are ‘blank nodes’. They tell Dgraph to create a node, give it an internal id and make sure it’s used consistently.
After the upload, the label _:company1 doesn’t exist in Dgraph and we can’t query for it.</description>
    </item>
    
    <item>
      <title>Min and Max</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/aggregation/2/</link>
      <pubDate>Thu, 27 Apr 2017 15:42:57 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/aggregation/2/</guid>
      <description>The min and max aggreation functions can be used on all scalar types. That is: int, float, string, bool, id and date.
Agregations don&amp;rsquo;t require an index, but can only be applied to variables</description>
    </item>
    
    <item>
      <title>Graphs as results</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/2/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:22 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/2/</guid>
      <description>The last query got us some data, but the result wasn’t very interesting, nor was it much to do with graphs.
In Dgraph and GraphQL+-, queries return graphs, not tables or lists of data.
A query is executed against a graph and the result is a subset of the queried graph, or some manipulation or calculation based on the queried graph.
Let’s improve the query to get Michael and his network of friends.</description>
    </item>
    
    <item>
      <title>Run Dgraph</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/intro/2/</link>
      <pubDate>Wed, 26 Apr 2017 22:14:20 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/intro/2/</guid>
      <description>Let&amp;rsquo;s run an instance of Dgraph on your machine; that&amp;rsquo;ll give you a handle on installing Dgraph and loading data yourself.
All the data in this tutorial will be stored in the instance you install, and all the queries will look for Dgraph on your local machine. By running it in a container, you&amp;rsquo;ll have a fresh Dgraph that will serve as a sandbox for you to learn and experiment.</description>
    </item>
    
    <item>
      <title>Regular Expressions</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/search/3/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/search/3/</guid>
      <description>Regular expressions require the trigram index. A trigram is a substring of 3 consecutive characters, or runes.
The trigrams of trigram are: tri, rig, igr, gra and ram.
Valid regular expressions are able to be converted to a trigram query against the index. Dgraph searches the trigram index for possible matches and then runs the full regular expression against the possibles.
Each regular expressions must match at least one trigram.</description>
    </item>
    
    <item>
      <title>Query Variables in a child block</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/3/</link>
      <pubDate>Mon, 01 May 2017 20:47:01 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/3/</guid>
      <description>Query variables in a child block allow the query to carry answers matched at one level down to the children to filter against.
For example, take of the set of actors in all Jane Campion films; our challenge is to find which pairs in that set have acted together on a film not directed by Jane Campion.
The query here uses the sets of all Jane Campion&amp;rsquo;s films JC_films and all actors in any Jane Campion film JC_actors in child blocks.</description>
    </item>
    
    <item>
      <title>External Identifiers</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/schema/3/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:50 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/schema/3/</guid>
      <description>Dgraph doesn&amp;rsquo;t support setting external IDs for nodes. If an application requires unique identifiers for nodes other than the UIDs assigned by Dgraph, then these have to be supplied as edges. It&amp;rsquo;s up to a user application to ensure the uniqueness of such IDs/keys.
More about in https://docs.dgraph.io/mutations/#external-ids</description>
    </item>
    
    <item>
      <title>Data types, Schema and Type System</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/3/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:41 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/3/</guid>
      <description>It’s time to talk about data types and nodes
Type System Starting in version 1.1, Dgraph has support for a type system. At the moment, the type system is basic but can be used already to categorize nodes and query them based on their type. The type system is also used during expand queries.
So in order to Expand or Delete nodes. You need to define your Types correctly. You can see in detail more about the Type System here.</description>
    </item>
    
    <item>
      <title>Load Schema</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/intro/3/</link>
      <pubDate>Wed, 26 Apr 2017 22:28:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/intro/3/</guid>
      <description>Once you have Dgraph up and running, press run on the panel to the right. This will load a schema into Dgraph for us to use in the first steps of the tutorial. Don&amp;rsquo;t worry too much about the syntax for now, we&amp;rsquo;ll cover all that in later lessons, just check in the response panel that the operation was a success.
Note Note that Schema changes are made via Alter operations only.</description>
    </item>
    
    <item>
      <title>Exact index and inequality</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/search/4/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/search/4/</guid>
      <description>With the exact index inequalities on strings can be used in filters. Try the query after adding the exact index to the string indexes.
The hash index allows fast filtering for eq on strings.</description>
    </item>
    
    <item>
      <title>Query Variables in another query block I</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/4/</link>
      <pubDate>Mon, 01 May 2017 20:48:27 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/4/</guid>
      <description>Let&amp;rsquo;s take a second to think about that last query. The variable JC_actor evaluated to all actors in any Jane Campion film. No matter where we use it, it&amp;rsquo;s the full set.
That&amp;rsquo;s the key to using Dgraph&amp;rsquo;s variables correctly: understand that they are global in the sense that they evaluate to all nodes that could match that edge in the query, not local in the sense that would evaluate to different results for each Jane Campion film.</description>
    </item>
    
    <item>
      <title>Language Support</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/schema/4/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:50 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/schema/4/</guid>
      <description>Language tags are used on the string on input
_:myID &amp;lt;an_edge&amp;gt; &amp;quot;something&amp;quot;@en . _:myID &amp;lt;an_edge&amp;gt; &amp;quot;某物&amp;quot;@zh-Hans . and on the edge in a query.
You can do the same example using JSON format. You&amp;rsquo;re able to do that through our clients, cURL or Ratel UI.
See the JSON:
 { &amp;quot;set&amp;quot;: [ { &amp;quot;uid&amp;quot;: &amp;quot;_:myID&amp;quot;, &amp;quot;an_edge@en&amp;quot;: &amp;quot;something&amp;quot;, &amp;quot;an_edge@zh-Hans&amp;quot;: &amp;quot;某物&amp;quot; } ] }  Tip The JSON example may end up helping you better understand the format in RDF.</description>
    </item>
    
    <item>
      <title>Language Support</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/4/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:45 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/4/</guid>
      <description>Dgraph supports string text and queries as UTF-8.
String valued predicates can be annotated with a language tag.
Amit&amp;rsquo;s name was stored in English &amp;quot;Amit&amp;quot;@en, Hindi &amp;quot;अमित&amp;quot;@hi and Bengali &amp;quot;অমিত&amp;quot;@bn. Michael&amp;rsquo;s was stored in English. Artyom&amp;rsquo;s was stored in English and Russian &amp;quot;Артём&amp;quot;@ru. Sang Hyun&amp;rsquo;s was stored in English and Korean &amp;quot;상현&amp;quot;@ko.
Queries can search over text in the tagged languages by specifying which language to search and which languages to return.</description>
    </item>
    
    <item>
      <title>Load Data</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/intro/4/</link>
      <pubDate>Wed, 26 Apr 2017 22:28:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/intro/4/</guid>
      <description>Now that a schema has been loaded, it&amp;rsquo;s time to load some data. Press the run button again and check that the response panel indicates the data was loaded successfully.
Don&amp;rsquo;t worry about the syntax for now, it will be explained later.
You can load the same example data using JSON format. You&amp;rsquo;re able to do that through our clients, cURL or Ratel UI.
See the JSON:
 Show answer   { &amp;quot;set&amp;quot;: [ { &amp;quot;uid&amp;quot;: &amp;quot;_:michael&amp;quot;, &amp;quot;name&amp;quot;: &amp;quot;Michael&amp;quot;, &amp;quot;dgraph.</description>
    </item>
    
    <item>
      <title>Mutation Introduction</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/intro/5/</link>
      <pubDate>Sun, 04 Nov 2018 22:28:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/intro/5/</guid>
      <description>In the last exercise, you added some data into Dgraph. Adding or removing data in Dgraph is called a mutation. We have two types of standard formats for mutations: RDF (Resource Description Framework) N-Quad and JSON (JavaScript Object Notation). RDF is a widely used standard in Graph or Ontology systems.
In Dgraph the mutation operations consist of two patterns: blank UID reference or explicit UID reference.
This introduction is important for the coming exercises, many of the concepts presented here will be repeated in the next few chapters.</description>
    </item>
    
    <item>
      <title>Full Text Search</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/search/5/</link>
      <pubDate>Mon, 15 May 2017 15:31:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/search/5/</guid>
      <description>Full text search is what Google does for web pages. It&amp;rsquo;s different to term matching because it tries to respect language, grammar and tense. For example, matching search term run with documents containing run, running and ran.
It doesn&amp;rsquo;t match terms exactly and instead makes use of
 stemming : finding a common base word so differences in tense, plural/singular or other inflection are still matched, and stop words : removing words such as and, or, it and maybe that occur too often to search over.</description>
    </item>
    
    <item>
      <title>Query Variables in another query block II</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/5/</link>
      <pubDate>Mon, 01 May 2017 20:48:30 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/5/</guid>
      <description>Query variables used in other query blocks also allow to reorganize results.</description>
    </item>
    
    <item>
      <title>Reverse edges</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/schema/5/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:50 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/schema/5/</guid>
      <description>Edges are directional. A query can&amp;rsquo;t traverse an edge in reverse.
There are two choices to query in both directions
  Add the reverse edge to the schema and add all the reverse edge data.
  Tell Dgraph to always store the reverse edge using the @reverse keyword in the schema.
  Run the schema mutation and Dgraph will compute all the reverse edges. The reverse edge of an_edge is ~an_edge.</description>
    </item>
    
    <item>
      <title>Queries describe graphs</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/5/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:45 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/5/</guid>
      <description>Dgraph query results are graphs. In fact, the result structure matches the query structure.
The braces edge_name { ... } in the query signify nested blocks where the edges inside the block are matched against nodes found by following the edge that begins the block. We continue nesting the query as we follow edges from node to node.
While not strictly required, it’s a good style to indent the query.</description>
    </item>
    
    <item>
      <title>Reverse edges Query</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/schema/6/</link>
      <pubDate>Mon, 13 May 2019 23:05:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/schema/6/</guid>
      <description>The reverse edge of anEdge is ~anEdge.
In this query we want to know who works for &amp;ldquo;CompanyABC&amp;rdquo; without having to add extra edges. So we use a reverse edge for the specific case. And then we use an alias &amp;ldquo;work_here&amp;rdquo; to differentiate the query result.</description>
    </item>
    
    <item>
      <title>Full Text Search : language support</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/search/6/</link>
      <pubDate>Mon, 15 May 2017 15:32:13 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/search/6/</guid>
      <description>Full text search works only for languages for which there are stemming procedures and stop word lists.
Currently, Dgraph supports
   Language Country Code     Danish da   Dutch nl   English en   Finnish fi   French fr   German de   Hungarian hu   Italian it   Norwegian no   Portuguese pt   Romanian ro   Russian ru   Spanish es   Swedish sv   Turkish tr   Chinese zh   Japanese ja   Korean ko    </description>
    </item>
    
    <item>
      <title>Exercise: Query Variables linking queries</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/6/</link>
      <pubDate>Mon, 01 May 2017 20:48:32 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/6/</guid>
      <description>We&amp;rsquo;ve seen two common uses for variables: filtering and reorganizing results. Another is linking two queries to gain some new insight based on the joined results.
Let&amp;rsquo;s look at an example of joining two queries.
For two directors find the actors who have worked with both (not necessarily on the same movie). Many directors won&amp;rsquo;t have actors in common, so start with some you are sure will (the answer below uses Peter Jackson and Martin Scorsese who have a small number of actors in common).</description>
    </item>
    
    <item>
      <title>Functions and filtering</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/6/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:47 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/6/</guid>
      <description>Nodes are filtered based on functions applied to the node&amp;rsquo;s outgoing edges.
So far the queries have only applied a filter to the top level nodes, but filters can be applied to any node in the query.
Note the syntax difference between filtering at the root of a query and filtering on internal blocks.
There are many functions for filtering, some of them are
  allOfTerms(edge_name, &amp;quot;term1 ... termN&amp;quot;): matches nodes with an outgoing string edge edge_name where the string contains all listed terms.</description>
    </item>
    
    <item>
      <title>Graphs</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/intro/6/</link>
      <pubDate>Wed, 26 Apr 2017 22:28:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/intro/6/</guid>
      <description>We&amp;rsquo;ve started Dgraph, but first things first: What is a graph and what has that got to do with databases?
Graphs describe objects and the interconnections between them. Many people have heard of friendship graphs, or social network graphs, so let’s start there.
Note OK, you&amp;rsquo;ll have to use your imagination here. We&amp;rsquo;re still building the tutorial, and we don&amp;rsquo;t have the visualizations up and running just yet. By starting Dgraph, you&amp;rsquo;ll have the visualization component working just fine.</description>
    </item>
    
    <item>
      <title>Geo queries : Near</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/search/7/</link>
      <pubDate>Mon, 15 May 2017 15:32:26 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/search/7/</guid>
      <description>Coming soon.</description>
    </item>
    
    <item>
      <title>Value variables - min and max</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/7/</link>
      <pubDate>Tue, 02 May 2017 11:01:04 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/7/</guid>
      <description>We&amp;rsquo;ve just looked at variables that stored uid results from query blocks. Value variables store the values against which they match.
Value variables work differently to query variables. Value variables are context dependent - in fact, they are a map from UID to value and we can exploit this when reading and filtering value variables. The value from a value variable is extracted with val(&amp;lt;variable-name&amp;gt;).
At the point of definition, because the context is within the appropriate UID, value variables act like the corresponding value.</description>
    </item>
    
    <item>
      <title>Exercise : Integrating existing data</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/schema/7/</link>
      <pubDate>Mon, 01 May 2017 10:41:33 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/schema/7/</guid>
      <description>We&amp;rsquo;ve added a new schema and loaded some company data, but what about integrating our previous friends dataset with this company one.
Trying to use the blank nodes from previous mutations won&amp;rsquo;t work. The blank nodes aren&amp;rsquo;t persisted in the store, so when referring to nodes created in a previous mutation, it&amp;rsquo;s the UID that&amp;rsquo;s needed. So instead of
_:sarah &amp;lt;works_for&amp;gt; _:company1 . it&amp;rsquo;s
&amp;lt;uid-for-sarah&amp;gt; &amp;lt;works_for&amp;gt; &amp;lt;uid-for-company1&amp;gt; . Because the uid picked by Dgraph is unique, we can&amp;rsquo;t help you this time.</description>
    </item>
    
    <item>
      <title>AND, OR and NOT</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/7/</link>
      <pubDate>Wed, 26 Apr 2017 22:36:51 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/7/</guid>
      <description>The logical connectives AND, OR and NOT combine multiple functions in a filter.</description>
    </item>
    
    <item>
      <title>Graph Databases</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/intro/7/</link>
      <pubDate>Wed, 26 Apr 2017 22:28:58 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/intro/7/</guid>
      <description>A graph database is a database optimized for storing and querying graphs. When it comes to relationships, graph databases are much faster than SQL databases.
SQL databases get bogged down by graph-like data because following edges means joining tables; sometimes big tables; the more edges, the more joins, and the more data needs to be loaded and processed.
In a graph database, the edges are a fundamental structure, so following edges is a single lookup, making this operation blazingly fast.</description>
    </item>
    
    <item>
      <title>Exercise : Value variables - sum and avg</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/8/</link>
      <pubDate>Tue, 02 May 2017 11:01:06 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/8/</guid>
      <description>Summation sum and average avg can only be applied to value variables that contain int and float data.
Find which is greater, the number of movies by Steven Spielberg or the average number of actors in movies directed by him.
This query can be done in a single block, but you&amp;rsquo;ll see here how values are available in other blocks if the corresponding UID&amp;rsquo;s are available for the value map.</description>
    </item>
    
    <item>
      <title>Deleting Data</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/schema/8/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:53 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/schema/8/</guid>
      <description>There are three deletion options inside a delete mutation.
 &amp;lt;uid&amp;gt; &amp;lt;edge&amp;gt; &amp;lt;uid&amp;gt;/&amp;quot;value&amp;quot; . Delete a single triple &amp;lt;uid&amp;gt; &amp;lt;edge&amp;gt; * . Delete all triples for a given edge &amp;lt;uid&amp;gt; * * . Delete all triples for a given node  The examples given here are not complete. Uids assigned on your instance would be unique. Try something out; you&amp;rsquo;re not going to hurt anyone, just delete their friends.
You can do the same example using JSON format.</description>
    </item>
    
    <item>
      <title>Sorting (orderasc or orderdesc)</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/8/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:34 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/8/</guid>
      <description>Results can be ordered using orderasc and orderdesc.
The visualization will look the same as without the sorting, but the JSON result is ordered.</description>
    </item>
    
    <item>
      <title>Congratulations</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/intro/8/</link>
      <pubDate>Wed, 26 Apr 2017 22:29:00 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/intro/8/</guid>
      <description>Congratulations, you&amp;rsquo;ve finished the first module of the tutorial.
By now you should have Dgraph up and running for the tutorial and know a little about graphs.
Let’s investigate some graphs and start writing queries.</description>
    </item>
    
    <item>
      <title>Value variables: filtering and ordering</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/9/</link>
      <pubDate>Tue, 02 May 2017 11:01:09 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/9/</guid>
      <description>If the context provided by the UIDs of the block is correct, value variables can also be used in filtering and ordering.
Here, ID will be the UID&amp;rsquo;s of all directors of name Steven and average is a map from those UID&amp;rsquo;s to the average for each director. The filtering, ordering and result for var(average) are evaluated in that context to obtain each value.
A value variable can be used in place of a UID variable, uid(&amp;lt;value-variable&amp;gt;) evaluates to the UID&amp;rsquo;s in the map.</description>
    </item>
    
    <item>
      <title>Expand Predicate</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/schema/9/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/schema/9/</guid>
      <description>expand(...predicates...) is used to query for all given predicates, rather than listing them in the query. Querying
expand(_all_) queries returns all edges out of every node matched at that level in the query. Expand can be nested to then expand all predicates at the next level.
We&amp;rsquo;ll see later how to use expand with variables to query for a particular set of edges.
Note As of version v1.1 you will need to add Types in your schema for expand(_all_) to work.</description>
    </item>
    
    <item>
      <title>Pagination (first, offset and after)</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/9/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:36 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/9/</guid>
      <description>It&amp;rsquo;s not uncommon to have thousands of results for a query.
But you might want to select only the top-k answers, paginate the results for display, or limit a large result.
In GraphQL+- this is done with first, offset and after in combination with ordering.
 first: N Return only the first N results offset: N Skip the first N results after: uid Return the results after uid  By default, query answers are ordered by uid.</description>
    </item>
    
    <item>
      <title>Value variables: math functions</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/10/</link>
      <pubDate>Tue, 02 May 2017 11:01:09 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/10/</guid>
      <description>As well as min, max, avg, and sum to aggregate, Dgraph supports a host of functions that can be applied to value variables. These need to be enclosed in math(...) and stored in a variable.
The full list is:
   Operator Accepted Type Notes     + - * / % int and float    min max All types except geo and bool    &amp;lt; &amp;gt; &amp;lt;= &amp;gt;= == !</description>
    </item>
    
    <item>
      <title>Congratulations</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/schema/10/</link>
      <pubDate>Thu, 27 Apr 2017 23:05:55 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/schema/10/</guid>
      <description>This is the end of the schema module.
The Dgraph instance you have running for the tutorial and the lessons in the modules so far give you a sandbox to play in. Make whatever queries or changes you like until you are comfortable with the material covered so far.
When you&amp;rsquo;re done, let&amp;rsquo;s move up to bigger datasets and see more of Dgraph&amp;rsquo;s query language.</description>
    </item>
    
    <item>
      <title>Count</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/10/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:40 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/10/</guid>
      <description>The number of outgoing edges can be counted, using the count function.</description>
    </item>
    
    <item>
      <title>Exercise : Latest Movies</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/11/</link>
      <pubDate>Tue, 02 May 2017 11:01:12 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/11/</guid>
      <description>Write a query to find the most recently released movie by each director and order the result by the release dates.
If you need some hints try:  Show answer  To solve this, you&amp;rsquo;ll need to
 work out how to query for all directors - what have directors done that make them directors? find the most recent release date for each director sort the results by the most recent release return the directors name, and the details of the most recent release you&amp;rsquo;ll need one query to get the directors and their latest movies, and another query to sort this to get most recent movies first for something extra, try using since to work out how many days since the movie was released (or how many days till release, for some)    Spoiler alert:  Show answer  { # Get all directors var(func: has(director.</description>
    </item>
    
    <item>
      <title>How Dgraph Search Works</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/11/</link>
      <pubDate>Mon, 01 May 2017 11:55:43 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/11/</guid>
      <description>Given what you&amp;rsquo;ve seen so far, you&amp;rsquo;ve probably already understood this, but it&amp;rsquo;s worth going over.
The graphs in Dgraph can be huge, so starting searching from all nodes isn&amp;rsquo;t efficient. Dgraph needs a place to start searching, that&amp;rsquo;s the root node.
At root, we use func: and a function to find an initial set of nodes. So far we&amp;rsquo;ve used eq and allofterms for string search, but we can also search on other values like dates, numbers, and also filters on count.</description>
    </item>
    
    <item>
      <title>GroupBy</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/12/</link>
      <pubDate>Tue, 02 May 2017 11:01:12 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/12/</guid>
      <description>A groupby query aggregates query results given a set of properties on which to group elements. For example, a query containing the block
director.film @groupby(genre) { a as count(uid) } finds nodes reachable along the director.film edge, partitions these into groups based on genre, then counts how many nodes are in each group.
Inside a groupby block, only aggregations are allowed and count can only be applied to uid.
The result is the grouped edges and the value variables for the aggregations.</description>
    </item>
    
    <item>
      <title>Has</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/12/</link>
      <pubDate>Mon, 01 May 2017 11:55:43 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/12/</guid>
      <description>The function has(edge_name) returns nodes that have an outgoing edge of the given name.</description>
    </item>
    
    <item>
      <title>Congratulations!</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/13/</link>
      <pubDate>Tue, 02 May 2017 11:01:12 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/blocksvars/13/</guid>
      <description>You&amp;rsquo;ve finished this lesson.
Next up, string and geo searching. Or use the index to go to another topic.</description>
    </item>
    
    <item>
      <title>Alias</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/13/</link>
      <pubDate>Mon, 01 May 2017 11:55:43 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/13/</guid>
      <description>The output graph can set names for edges in the output with aliasing.</description>
    </item>
    
    <item>
      <title>Cascade</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/14/</link>
      <pubDate>Mon, 01 May 2017 11:55:46 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/14/</guid>
      <description>The @cascade directive removes any nodes that don&amp;rsquo;t have all matching edges in the query.
Another use is to remove nodes where a filter inside a block returns no results.
In the query below, Dgraph returns all Michael&amp;rsquo;s friends, and only the friends of friends who are over 27.
{ michael_friends(func: allofterms(name, &amp;quot;Michael&amp;quot;)) { name age friend { name@. friend @filter(ge(age, 27)) { name@. age } } } } With the @cascade directive, friends of Michael that don&amp;rsquo;t have friends who are over 27 are not included in the result.</description>
    </item>
    
    <item>
      <title>Normalize</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/15/</link>
      <pubDate>Mon, 01 May 2017 11:55:49 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/15/</guid>
      <description>The @normalize directive
  returns only edges listed with an alias, and
  flattens the result to remove nesting
  Tip Aliased names can be the same as the original edge.
 </description>
    </item>
    
    <item>
      <title>Comments</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/16/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/16/</guid>
      <description>Queries can contain comments.
Anything after # on a line is a comment and ignored for query processing.
This is helpful for debugging queries and for tutorials that need to explain parts of queries in-line, which is what we&amp;rsquo;ll do for the more complex queries you&amp;rsquo;ll encounter later in the tutorial.</description>
    </item>
    
    <item>
      <title>Facets : Edge attributes</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/17/</link>
      <pubDate>Mon, 17 Sep 2018 16:11:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/17/</guid>
      <description>Dgraph supports facets — key value pairs on edges — as an extension to RDF triples. That is, facets add properties to edges, rather than to nodes. For example, a friend edge between two nodes may have a boolean property of close friendship. Facets can also be used as weights for edges.
More details about Facets you can find in our Docs: https://docs.dgraph.io/query-language/#facets-edge-attributes
Reading all the documentation about Facets you will have examples of:</description>
    </item>
    
    <item>
      <title>Congratulations</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/basic/18/</link>
      <pubDate>Wed, 26 Apr 2017 23:11:42 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/basic/18/</guid>
      <description>You’ve finished the lesson.
You can use the material in this lesson to query graphs, filter the output, and sort and paginate the results.
Check out the list of sections again, go back and review anything that wasn&amp;rsquo;t clear, or go on with the next lesson.</description>
    </item>
    
    <item>
      <title>Lesson Title</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/sample/3/</link>
      <pubDate>Wed, 26 Apr 2017 16:24:06 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/sample/3/</guid>
      <description>Hello world</description>
    </item>
    
    <item>
      <title>Some Title</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/sample/2/</link>
      <pubDate>Wed, 26 Apr 2017 16:16:25 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/sample/2/</guid>
      <description>Some Content</description>
    </item>
    
    <item>
      <title>Reverse Edges</title>
      <link>https://dgraph.io/tour/dgraph-1.2.1/sample/1/</link>
      <pubDate>Wed, 26 Apr 2017 14:47:31 +1000</pubDate>
      
      <guid>https://dgraph.io/tour/dgraph-1.2.1/sample/1/</guid>
      <description>Each graph edge is unidirectional. It points from one node to another.
A lot of times, you wish to access data in both directions, forward and backward.
Instead of having to send edges in both directions, you can use the @reverse keyword at the end of a uid (entity) field declaration in the schema.
This specifies that the reverse edge should be automatically generated. For example, if we want to add a reverse edge for directed_by predicate, we should have a schema as follows.</description>
    </item>
    
  </channel>
</rss>